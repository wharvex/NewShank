using LLVMSharp.Interop;
using Shank.ExprVisitors;

namespace Shank;

// a facade around a llvm value ref to make it more type safe and also to be able to get the actual type of the function as opposed to a function pointer type
// TODO: move all llvm facades to their own file
public struct LLVMFunction
{
    public LLVMValueRef Function { get; private set; }
    public LLVMTypeRef ReturnType => TypeOf.ReturnType;
    public LLVMTypeRef TypeOf { get; }

    public LLVMFunction(LLVMModuleRef module, string name, LLVMTypeRef type)
    {
        Function = module.AddFunction(name, type);
        TypeOf = type;
    }
    
    public LLVMLinkage Linkage
    {
        get => Function.Linkage;
        set => Function = Function with { Linkage = value };
    }

    public LLVMValueRef GetParam(uint index) => Function.GetParam(index);

    public LLVMBasicBlockRef AppendBasicBlock(string entry) => Function.AppendBasicBlock(entry);
}

// this class adds extension methods to llvm modules to add functions, but return them to us as our llvm function facade
public static class LLVMAddFunctionExtension
{
    public static LLVMFunction addFunction(this LLVMModuleRef module, string name, LLVMTypeRef type)
    {
        return new LLVMFunction(module, name, type);
    }
}
/// <summary>
/// container for Varaibles (we need a type and refrence)
/// </summary>
public struct LlvmVaraible
{
    public LLVMValueRef ValueRef { get; set; }
    public LLVMTypeRef TypeRef { get; set; }

    public LlvmVaraible(LLVMValueRef valueRef, LLVMTypeRef typeRef)
    {
        ValueRef = valueRef;
        TypeRef = typeRef;
    }
}

// Functions "linked" from c that are used in code generated by the compiler
public struct CFuntions
{
    // adds the c functions to the module
    public CFuntions(LLVMModuleRef llvmModule)
    {
        var sizeT = LLVMTypeRef.Int32;
        printf = llvmModule.addFunction("printf", LLVMTypeRef.CreateFunction(sizeT, new LLVMTypeRef[]
        {
            LLVMTypeRef.CreatePointer(LLVMTypeRef.Int8,0)
        }, true));
        printf = printf with { Linkage = LLVMLinkage.LLVMExternalLinkage };
        // llvm does not like void pointers, so we most places I've seen use i8* instead
        var voidStar = LLVMTypeRef.CreatePointer(LLVMTypeRef.Int8, 0);
        memcpy = llvmModule.addFunction("memcpy",
            LLVMTypeRef.CreateFunction(voidStar, [voidStar, voidStar, sizeT]));
        memcpy = memcpy with { Linkage = LLVMLinkage.LLVMExternalLinkage };
        malloc = llvmModule.addFunction("malloc",
            LLVMTypeRef.CreateFunction(voidStar, [ sizeT]));
        malloc = malloc with { Linkage = LLVMLinkage.LLVMExternalLinkage };
    }

    //  int printf(const char *restrict format, ...);
    // sometimes llvm can optimize this to a puts
    public LLVMFunction printf { get; }
    // void *memcpy(void dest[restrict .n], const void src[restrict .n], size_t n);
    public LLVMFunction memcpy { get;  }
    // void *malloc(size_t n);
    public LLVMFunction malloc { get;  }
}
public class Context
{
    public LLVMTypeRef StringType = LLVMTypeRef.CreateStruct([LLVMTypeRef.Int32, LLVMTypeRef.CreatePointer(LLVMTypeRef.Int8, 0)], false);

    public Context(ModuleNode moduleNode, CFuntions cFuntions)
    {
        this.moduleNode = moduleNode;
        CFuntions = cFuntions;
    }


    public ModuleNode moduleNode { get; set; }
    public CFuntions CFuntions { get; }
    public LLVMFunction CurrentFunction { get; set; }
    public Dictionary<string, LLVMTypeRef> CustomTypes { get; } = new();
    public Dictionary<string, LLVMFunction> Functions { get; } = new();
    public Dictionary<string, LlvmVaraible> Variables { get; set; } = new();

    // global variables, constants or variables defined at the top level
    private Dictionary<string, LlvmVaraible> GloabalVariables { get; } = new();

    /// <summary>
    /// converts shank type to LLVM type
    /// </summary>
    /// <param name="dataType"></param>
    /// <param name="unknownType"></param>
    /// <returns></returns>
    public LLVMTypeRef? GetLLVMTypeFromShankType(
        VariableNode.DataType dataType,
        string? unknownType = null
    ) =>
        dataType switch
        {
            VariableNode.DataType.Integer => LLVMTypeRef.Int64,
            VariableNode.DataType.Real => LLVMTypeRef.Double,
            VariableNode.DataType.String => StringType,
            VariableNode.DataType.Boolean => LLVMTypeRef.Int1,
            VariableNode.DataType.Character => LLVMTypeRef.Int8,
            // if it's a custom type we look it up in the context
            VariableNode.DataType.Reference when unknownType != null
                => LLVMTypeRef.CreatePointer(CustomTypes[unknownType], 0),
            VariableNode.DataType.Array => LLVMTypeRef.Void,
            _ when unknownType != null => CustomTypes[unknownType],
            _ => null
        };

    /// <summary>
    /// helper function. it retusns the visitor type
    /// </summary>
    /// <param name="dataType"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public Visitor GetExprFromType(LLVMTypeRef typeRef)
    {
        if (typeRef == LLVMTypeRef.Int64)
            return new IntegerExprVisitor();
        else if (typeRef == LLVMTypeRef.Int8)
            return new CharExprVisitor();
        else if (typeRef == LLVMTypeRef.Int1)
            return new BoolExprVisitor();
        else if (typeRef == LLVMTypeRef.Double)
            return new FloatExprVisitor();
        else if (typeRef == StringType)
            return new StringExprVisitor();
        else
            throw new Exception("undefined type");
    }

    /// <summary>
    /// gets the varaible
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public LlvmVaraible GetVaraible(string name)
    {
        if (GloabalVariables.TryGetValue(name, out var GlobalVar))
        {
            return GlobalVar;
        }
        else if (Variables.TryGetValue(name, out var varaible))
        {
            return varaible;
        }
        else
        {
            throw new Exception("undefined varname");
        }
    }

    /// <summary>
    /// adds a varaivle to the dictionary
    /// </summary>
    /// <param name="name">var name (the key)</param>
    ///
    /// <param name="valueRef">the LLVMref (needed for assignments)</param>
    /// <param name="type">Data type the varaible is</param>
    /// <param name="isGlobal">IsGlobal</param>
    /// <exception cref="Exception">if it already exists</exception>
    public void AddVaraible(string name, LLVMValueRef valueRef, LLVMTypeRef type, bool isGlobal)
    {
        if (GloabalVariables.ContainsKey(name) || Variables.ContainsKey(name))
            throw new Exception("error");
        else if (isGlobal)
            GloabalVariables.Add(name, new LlvmVaraible(valueRef, type));
        else
            Variables.Add(name, new LlvmVaraible(valueRef, type));
    }

    /// <summary>
    /// resets the Varaible dictionary run at the end of a function
    /// </summary>
    public void ResetLocal()
    {
        Variables = new();
    }

    public void addFunction(string name, LLVMFunction function)
    {
        Functions[name] = function;
    }

    public LLVMFunction GetFunction(string name)
    {
        return Functions[name];
    }
}
